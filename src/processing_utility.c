#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include "../include/stat_data_dump.h"
#include "../include/avl_tree.h"

#define NUM_ARGS 4
#define NUM_ELEMENTS_TO_PRINT 10

void *merge_stat_data(void *a, void *b);
void copy_stat_data(void *array, void *data, unsigned long index);

static long get_file_size(const char *filename);
static stat_data_dump* load_dump(const char *file_name);
static void store_dump(stat_data_dump *dump, const char *file_name);
static node* avl_tree_from_dump(node *root, stat_data_dump *dump, unsigned long *num_el);
static stat_data_dump* join_dump(stat_data_dump *dump_a, stat_data_dump *dump_b);
static stat_data_dump* sort_dump(stat_data_dump *dump);
static void print_dump(stat_data_dump *dump);
static void dump_cleanup(stat_data_dump *dump);

int main(int argc, char *argv[])
{
    if (argc != NUM_ARGS)
    {
        fprintf(stderr, "Incorrect number of arguments!\n\n");
        fprintf(stderr,
            "Usage: %s <input-file-1> <input-file-2> <result-file>\n"
            "Process two binary files generated by test-utility and save the processing result.\n\n"
            "Arguments:\n"
            "  <input-file-1>   Path to first stat_data binary file\n"
            "  <input-file-2>   Path to second stat_data binary file\n"
            "  <result-file>    Output file for processing results\n\n"
            "Example:\n"
            "  %s dump1.bin dump2.bin output.bin\n",
            argv[0], argv[0]
        );
        exit(EXIT_FAILURE);
    }

    stat_data_dump* dump_a = load_dump(argv[1]);
    stat_data_dump* dump_b = load_dump(argv[2]);

    stat_data_dump* dump_c = join_dump(dump_a, dump_b);
    /* Было 2 пустых файла, создаём пустой файл и выходим */
    if (!dump_c)
    {
        store_dump(NULL, argv[3]);
        exit(EXIT_SUCCESS);
    }

    /* Отчищаем память от ненужных теперь dump'ов*/
    dump_cleanup(dump_a);
    dump_cleanup(dump_b);

    dump_c = sort_dump(dump_c);

    print_dump(dump_c);
    store_dump(dump_c, argv[3]);

    dump_cleanup(dump_c);

    exit(EXIT_SUCCESS);
}

void *merge_stat_data(void *a, void *b)
{
    stat_data *ptr_a = (stat_data *)a;
    stat_data *ptr_b = (stat_data *)b;

    ptr_a->count = ptr_a->count + ptr_b->count;
    ptr_a->cost = ptr_a->cost + ptr_b->cost;
    ptr_a->primary = ptr_a->primary & ptr_b->primary;
    ptr_a->mode = (ptr_a->mode > ptr_b->mode) ? ptr_a->mode : ptr_b->mode;

    return (void *)ptr_a;
}

void copy_stat_data(void *array, void *data, unsigned long index)
{
    /* Преобразуем указатели и копируем */
    stat_data *dest = (stat_data *)((char *)array + index * sizeof(stat_data));
    stat_data *src = (stat_data *)data;

    memcpy(dest, src, sizeof(stat_data));
}

int compare_cost(const void *a, const void *b) {
    const stat_data *data_a = (const stat_data *)a;
    const stat_data *data_b = (const stat_data *)b;

    if (data_a->cost < data_b->cost)
    {
        return -1;
    }
    if (data_a->cost > data_b->cost)
    {
        return 1;
    }
    return 0;
}

static long get_file_size(const char *filename) {
    struct stat st;

    if (stat(filename, &st) == 0)
    {
        return st.st_size;
    }
    else
    {
        perror("Failed to get size of file");
        return 0;
    }
}

static stat_data_dump* load_dump(const char *file_name)
{
    size_t ret;
    FILE *file;
    unsigned long file_size;
    unsigned long num_elements;
    stat_data *array = NULL;
    stat_data_dump *dump = NULL;

    if ((file = fopen(file_name, "rb")) == NULL)
    {
        perror("Failed to open file");
        exit(EXIT_FAILURE);
    }

    file_size = get_file_size(file_name);
    if (file_size == 0)
        return NULL;

    num_elements = file_size / sizeof(stat_data);
    array = (stat_data *)malloc(num_elements * sizeof(stat_data));
    if (array == NULL)
    {
        fprintf(stderr, "Failed to allocate memory!\n");
        exit(EXIT_FAILURE);
    }
    dump = (stat_data_dump *)malloc(sizeof(stat_data_dump));
    if (dump == NULL)
    {
        fprintf(stderr, "Failed to allocate memory!\n");
        exit(EXIT_FAILURE);
    }

    ret = fread(array, sizeof(stat_data), num_elements, file);
    if (ret != num_elements)
    {
        fprintf(stderr, "Failed to read data from file\n");
        exit(EXIT_FAILURE);
    }

    fclose(file);
    dump->array = array;
    dump->num_elements = num_elements;
    return dump;
}

static void store_dump(stat_data_dump *dump, const char *file_name)
{
    size_t ret;
    FILE *file;

    if ((file = fopen(file_name, "wb")) == NULL)
    {
        perror("Failed to open file");
        exit(EXIT_FAILURE);
    }
    if(dump != NULL)
    {
        ret = fwrite(dump->array, sizeof(stat_data), dump->num_elements, file);
        if (ret != dump->num_elements)
        {
            fprintf(stderr, "Failed to write data to file\n");
            exit(EXIT_FAILURE);
        }
    }

    fclose(file);
    return;
}

static node* avl_tree_from_dump(node *root, stat_data_dump *dump, unsigned long *num_el)
{
    stat_data *element = dump->array;
    for (unsigned long i = 0; i < dump->num_elements; i++)
    {
        root = insert(root, element->id, (void *)element, merge_stat_data, num_el);
        element += 1;
    }
    return root;
}

/*
 * Создаём AVL-дерево, объединяющее два массива, смёрдживая элементы с одинаковым id.
 * Получившееся дерево сохраняем в новый dump для дальнейшей работы в ф-ии sort_dump().
 * P.S.
 * AVL-дерево позволяет удобно обрабатывать данные потоково, эффективно мёрджит
 * элементы с одинаковым id, позволяет быстро (за O(log N) в худшем случае) находить
 * элемент по id, если это потребуется.
 */
static stat_data_dump* join_dump(stat_data_dump *dump_a, stat_data_dump *dump_b)
{
    unsigned long num_el = 0;
    unsigned long index_ptr = 0;
    node* root = NULL;
    stat_data *array = NULL;
    stat_data_dump *dump_c = NULL;

    if (dump_a && dump_b)
    {
        root = avl_tree_from_dump(root, dump_a, &num_el);
        root = avl_tree_from_dump(root, dump_b, &num_el); // Расширяем AVL-дерево
        dump_c = (stat_data_dump *)malloc(sizeof(stat_data_dump));
        if (dump_c == NULL)
        {
            fprintf(stderr, "Failed to allocate memory!\n");
            exit(EXIT_FAILURE);
        }
        array = (stat_data *)malloc(sizeof(stat_data) * num_el);
        if (array == NULL)
        {
            fprintf(stderr, "Failed to allocate memory!\n");
            exit(EXIT_FAILURE);
        }
        dump_c->array = array;
        dump_c->num_elements = num_el;
        traverse_and_fill(root, (void *)array, &index_ptr, copy_stat_data);
        return dump_c;
    }
    else if(dump_a && !dump_b)
    {
        root = avl_tree_from_dump(root, dump_a, &num_el);
        dump_c = (stat_data_dump *)malloc(sizeof(stat_data_dump));
        if (dump_c == NULL)
        {
            fprintf(stderr, "Failed to allocate memory!\n");
            exit(EXIT_FAILURE);
        }
        array = (stat_data *)malloc(sizeof(stat_data) * num_el);
        if (array == NULL)
        {
            fprintf(stderr, "Failed to allocate memory!\n");
            exit(EXIT_FAILURE);
        }
        dump_c->array = array;
        dump_c->num_elements = num_el;
        traverse_and_fill(root, (void *)array, &index_ptr, copy_stat_data);
        return dump_c;
    }
    else if (!dump_a && dump_b)
    {
        root = avl_tree_from_dump(root, dump_b, &num_el);
        dump_c = (stat_data_dump *)malloc(sizeof(stat_data_dump));
        if (dump_c == NULL)
        {
            fprintf(stderr, "Failed to allocate memory!\n");
            exit(EXIT_FAILURE);
        }
        array = (stat_data *)malloc(sizeof(stat_data) * num_el);
        if (array == NULL)
        {
            fprintf(stderr, "Failed to allocate memory!\n");
            exit(EXIT_FAILURE);
        }
        dump_c->array = array;
        dump_c->num_elements = num_el;
        traverse_and_fill(root, (void *)array, &index_ptr, copy_stat_data);
        return dump_c;
    }
    else
    {
        return NULL;
    }
}

static stat_data_dump* sort_dump(stat_data_dump *dump)
{
    qsort(dump->array, dump->num_elements, sizeof(stat_data), compare_cost);
    return dump;
}

static void mode_to_bin(unsigned int mode, char *bin_str) {
    for (int i = 2; i >= 0; i--)
    {
        bin_str[2 - i] = (mode & (1 << i)) ? '1' : '0';
    }
    bin_str[3] = '\0';
}

static void print_dump(stat_data_dump *dump)
{
    stat_data *element = dump->array;
    int limit;
    if (dump->num_elements > NUM_ELEMENTS_TO_PRINT)
    {
        limit = NUM_ELEMENTS_TO_PRINT;
    }
    else
    {
        limit = dump->num_elements;
    }

    printf("%-10s %-10s %-15s %-8s %s\n",
           "id", "count", "cost", "primary", "mode");
    for (int i = 0; i < limit; i++)
    {
        char mode_bin[4];
        mode_to_bin(element->mode, mode_bin);

        printf("%#-10lx %-10d %-15.3e %-8c %s\n",
                element->id,
                element->count,
                element->cost,
                element->primary ? 'y' : 'n',
                mode_bin);
        element += 1;
    }

    return;
}

static void dump_cleanup(stat_data_dump *dump)
{
    free(dump->array);
    free(dump);
    return;
}
